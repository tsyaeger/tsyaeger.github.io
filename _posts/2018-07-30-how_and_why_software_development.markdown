---
layout: post
title:      "How and Why Software Development?"
date:       2018-07-30 17:03:20 -0400
permalink:  how_and_why_software_development
---

How did I get from public policy to software development? It's been a more natural career path than you might imagine.

From an abstract perspective, coding and policy analysis have a lot in common. Policy analysis is about systematically solving complex challenges. You clearly define a problem, layout criteria for success, consider risks and tradeoffs for possible solutions, and plan for well into the future. The goal is to find the highest leverage point at which to intervene so as to address the root cause in the most efficient manner. This translates well our coding objectives of scalability, efficiency, security, and distrust of assumptions.

Practically speaking, I drew closer to programming the more exposure I had to various analytical programs. In school some of my classes required proficiency in SPSS (for statistics), Excel, and Geographic Information Systems (GIS). Until then, I'd never imagined myself being good at these types of things, but I proved myself wrong. The more I learned, the more motivated I became to build my skills and to find new ways to apply them. 

My first policy job was with the NYC Taxi and Limousine Commission where we had to make sense of the millions of data points accumulated per day. I enjoyed sorting through the data to create reports and visualizations and to make decisions based on that information. However, I was on a management track and when some of my co-analysts had the opportunity to begin learning SQL and Python (which I hadn't even heard of until then), I'm not afraid to admit that I was deeply jealous. 

I left soon after (with a big chip on my shoulder) for a similar position in the private sector to work with even more data. In this position I taught myself SQL and Python and began using it for data analysis and to automate much of my job. The more programs I wrote, the more time I had to learn and to write additional programs. Eventually I realized that I wanted to build a larger variety of tools that people could use.  At that point my code was very procedural and ugly. It was clear I had a lot of work to do to get to web dev. Nonetheless, I was hooked. And here I am.







